import { spawn, SpawnOptions, ChildProcess } from "child_process";
import * as fs from "fs";
import * as path from "path";
import {
  JsonRpcProvider,
  Wallet,
  Contract,
  ContractFactory,
  NonceManager,
  parseEther,
} from "ethers";

const ROOT = path.resolve(__dirname, "../.."); // project root
const NODE_DIR = path.join(ROOT, "node");

function pjoin(...p: string[]) {
  return path.join(ROOT, ...p);
}
function exists(rel: string) {
  return fs.existsSync(pjoin(rel));
}

export async function run(
  cmd: string,
  args: string[],
  opts: SpawnOptions & { quiet?: boolean } = {},
) {
  return new Promise<{ code: number | null; stdout: string; stderr: string }>(
    (resolve, reject) => {
      const p = spawn(cmd, args, {
        cwd: ROOT,
        env: process.env,
        stdio: ["ignore", "pipe", "pipe"],
        ...opts,
      });
      let out = "";
      let err = "";
      if (p.stdout) p.stdout.on("data", (d) => { out += d.toString(); if (!opts.quiet) process.stdout.write(d); });
      if (p.stderr) p.stderr.on("data", (d) => { err += d.toString(); if (!opts.quiet) process.stderr.write(d); });
      p.on("error", reject);
      p.on("close", (code) => resolve({ code, stdout: out, stderr: err }));
    }
  );
}

export async function ensureDeps() {
  if (!exists("node/.venv/bin/python")) {
    await run("make", ["deps"]);
  }
}

export async function ensureCircuits() {
  const has =
    exists("circuits/xor_final.zkey") &&
    exists("circuits/XorCircuit_js/XorCircuit.wasm");
  if (!has) await run("make", ["circuit"]);
}

export async function ensureCompiled() {
  // compile after circuits (verifier generated by circuit step)
  await run("pnpm", ["hardhat", "compile"]);
}

export async function startNode(): Promise<{
  kill: () => void;
  url: string;
  accounts: { addr: string; pk: string }[];
}> {
  const node = spawn(
    "npx",
    ["hardhat", "node", "--hostname", "127.0.0.1", "--port", "8545"],
    {
      cwd: ROOT,
      env: process.env,
      stdio: ["ignore", "pipe", "pipe"],
    }
  );

  if (node.stdout) node.stdout.setEncoding("utf8");
  if (node.stderr) node.stderr.setEncoding("utf8");

  await new Promise<void>((resolve, reject) => {
    const to = setTimeout(() => reject(new Error("hardhat node start timeout")), 15000);
    node.on("error", reject);
    if (node.stdout) node.stdout.on("data", (d: string) => {
      process.stdout.write(d);
      if (d.includes("Started HTTP and WebSocket JSON-RPC server")) {
        clearTimeout(to);
        resolve();
      }
    });
    if (node.stderr) node.stderr.on("data", (d: string) => process.stderr.write(d));
  });

  const url = "http://127.0.0.1:8545";

  // fixed HH accounts (Hardhat default)
  const accounts = [
    { addr: "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266", pk: "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80" },
    { addr: "0x70997970C51812dc3A010C7d01b50e0d17dc79C8", pk: "0x59c6995e998f97a5a0044966f0945389dc9e86dae88c7a8412f4603b6b78690d" },
    { addr: "0x3C44CdDdB6a900fa2b585dd299e03d12FA4293BC", pk: "0x5de4111afa1a4b94908f83103eb1f1706367c2e68ca870fc3fb9a804cdab365a" },
    { addr: "0x90F79bf6EB2c4f870365E785982E1f101E93b906", pk: "0x7c852118294e51e653712a81e05800f419141751be58f605c371e15141b007a6" },
  ];

  return {
    kill: () => { try { node.kill("SIGINT"); } catch {} },
    url,
    accounts,
  };
}

export async function deployAll(url: string) {
  const provider = new JsonRpcProvider(url);

  // Use a NonceManager to avoid “nonce too low” races with automining.
  const base = new Wallet(
    "0xac0974bec39a17e36ba4a6b4d238ff944bacb478cbed5efcae784d7bf4f2ff80",
    provider
  );
  const wallet = new NonceManager(base);

  const verArt = JSON.parse(
    fs.readFileSync(
      pjoin("artifacts/contracts/Groth16Verifier.sol/Groth16Verifier.json"),
      "utf8"
    )
  );
  const orchArt = JSON.parse(
    fs.readFileSync(
      pjoin("artifacts/contracts/AiOrchestrator.sol/AiOrchestrator.json"),
      "utf8"
    )
  );

  const Ver = new ContractFactory(verArt.abi, verArt.bytecode, wallet);
  const ver = await Ver.deploy();
  // Wait for the tx receipt to be mined before sending the next tx.
  await ver.waitForDeployment();

  const Orch = new ContractFactory(orchArt.abi, orchArt.bytecode, wallet);
  const orch = await Orch.deploy(await ver.getAddress());
  await orch.waitForDeployment();

  return {
    provider,
    // Cast keeps existing test code (which expects Wallet-like type) happy.
    wallet: wallet as unknown as Wallet,
    verAddr: await ver.getAddress(),
    orchAddr: await orch.getAddress(),
    orchAbi: orchArt.abi,
  };
}

export function spawnWorker({
  url,
  orch,
  requestId,
  priv,
}: {
  url: string;
  orch: string;
  requestId: number;
  priv: string;
}) {
  const env = {
    ...process.env,
    RPC_URL: url,
    ORCH_ADDR: orch,
    REQUEST_ID: String(requestId),
    PRIVATE_KEY: priv,
  };
  const p = spawn(
    path.join(NODE_DIR, ".venv", "bin", "python"),
    ["compute_node.py"],
    {
      cwd: NODE_DIR,
      env,
      stdio: ["ignore", "pipe", "pipe"],
      detached: true, // so we can SIG the group on macOS/Linux
    }
  );
  if (p.stdout) p.stdout.on("data", (d) => process.stdout.write(d));
  if (p.stderr) p.stderr.on("data", (d) => process.stderr.write(d));
  return p;
}

function waitForExit(p: ChildProcess, timeoutMs = 5000) {
  return new Promise<void>((resolve) => {
    let done = false;
    const finish = () => { if (!done) { done = true; resolve(); } };
    const t = setTimeout(finish, timeoutMs);
    p.once("exit", () => { clearTimeout(t); finish(); });
    p.once("close", () => { clearTimeout(t); finish(); });
  });
}

export async function stopWorker(p: ChildProcess, timeoutMs = 4000) {
  try {
    const pid = p.pid;
    if (typeof pid !== "number") {
      try { p.kill("SIGINT"); } catch {}
      await waitForExit(p, timeoutMs);
      return;
    }
    try { process.kill(-pid, "SIGINT"); } catch {}
    try { p.kill("SIGINT"); } catch {}

    const t = setTimeout(() => {
      try { process.kill(-pid, "SIGKILL"); } catch {}
      try { p.kill("SIGKILL"); } catch {}
    }, timeoutMs);

    await waitForExit(p, timeoutMs + 1000);
    clearTimeout(t);
  } catch {
    // swallow
  }
}

/**
 * Open a request and return its id.
 * We avoid ABI type headaches by reading nextId *before* calling openRequest.
 */
export async function openRequest(
  orch: Contract,
  client: Wallet,
  minWorkers: number,
  bountyEth: string,
  grid: { lr: bigint; steps: bigint }[],
) {
  const O = orch.connect(client) as any;
  const nextId: bigint = await O.nextId();
  const tx = await O.openRequest("cid://xor", grid, minWorkers, {
    value: parseEther(bountyEth),
  });
  await tx.wait();
  return Number(nextId);
}

export async function waitClosed(orch: Contract, id: number, maxMs = 180000) {
  const O = orch as any;
  const start = Date.now();
  while (Date.now() - start < maxMs) {
    const r = await O.getResult(id);
    const closed = (r?.closed ?? r?.[0]) as boolean;
    if (closed) return r;
    await new Promise((res) => setTimeout(res, 1000));
  }
  throw new Error("Timeout waiting for settlement");
}

export async function showCredits(orch: Contract, id: number, addrs: string[]) {
  const O = orch as any;
  for (const a of addrs) {
    const c = await O.credit(id, a);
    console.log("credit", a, String(c));
  }
}

export function sleep(ms: number) {
  return new Promise((r) => setTimeout(r, ms));
}
